export default {
  error: {
    auth: {
      loginFailed: "Error al hacer login",
      refreshTokenNotProvided: "Token de actualizaci√≥n no proporcionado",
      failedToRefreshTokens: "Error al actualizar tokens",
      failedToLogout: "Error al hacer logout",
      failedToVerifyEmail: "Error al verificar e-mail",
      failedToResendLink: "Error al reenviar enlace de verificaci√≥n",
      failedToResetPassword: "Error al resetar contrase√±a",
      emailAlreadyExists: "E-mail ya existe",
      nameAlreadyExists: "Nombre ya existe",
      emailNotVerified: "Email no verificado",
      emailAlreadyVerified: "Email ya verificado",
      tokenNotProvided: "Token no proporcionado",
      invalidCredentials: "Credenciales inv√°lidas",
      missingRequiredParameter: "Par√°metro obligatorio:",
      invalidTokenFormat: "Formato de token inv√°lido",
      invalidToken: "Token inv√°lido",
      cookieNotBeProcessed: "Cookie de autorizaci√≥n no puede ser procesado",
      authHeaderNotFound: "Header de autorizaci√≥n no encontrado",
      authCookieNotFound: "Cookie de autorizaci√≥n no encontrado",
      accessTokenExpired: "Access token expirado",
      untrustedAccessToken: "Access token no confiable",
      accessTokenNotSigned: "Access token no firmado",
      invalidAccessToken: "Token de acceso inv√°lido",
      internalErrorAuthentication: "Error interno durante la autenticaci√≥n",
      userNotFound: "Usuario no encontrado",
      createUserError: "Error al crear usuario",
      resendLinkError: "Error al reenviar enlace de verificaci√≥n",
      resetPasswordLinkError: "Error al enviar link para redefinir contrase√±a",
      resetPasswordTokenNotFound:
        "Token de redefinici√≥n de contrase√±a no encontrado",
      resetPasswordTokenExpired: "Token de redefinici√≥n de contrase√±a expirado",
      resetPasswordError: "Error al redefinir contrase√±a",
      notAuthorized: "No autorizado",
    },
    handler: {
      internalServerError: "Error interno del servidor",
      recaptchaNotProvided: "reCAPTCHA no proporcionado",
      recaptchaInvalid: "reCAPTCHA inv√°lido",
      unauthorized: "No autorizado",
      tokenNotProvided: "Token no proporcionado",
      tokenExpired: "Token expirado",
      tokenInvalid: "Token inv√°lido",
      responseSerializationError: "Error de serializaci√≥n de respuesta",
    },
    user: {
      notFound: "Usuario no encontrado",
      getUserById: "Error al obtener usuario por id",
      getUserByEmail: "Error al obtener usuario por correo electr√≥nico",
      getUserByName: "Error al obtener usuario por nombre",
      getUsers: "Error al obtener usuarios",
    },
    invalidEnv: "Variables de entorno inv√°lidas:",
    ipBan: "IP temporalmente bloqueado debido a m√∫ltiples violaciones",
    rateLimitExceeded:
      "Demasiadas solicitudes, por favor intente de nuevo m√°s tarde",
  },
  validation: {
    email: {
      invalid: "Correo electr√≥nico inv√°lido",
      max: "Correo electr√≥nico debe tener como m√°ximo 254 caracteres",
    },
    password: {
      required: "La contrase√±a es requerida",
      min: "La contrase√±a debe tener al menos 8 caracteres",
      max: "La contrase√±a debe tener como m√°ximo 16 caracteres",
      uppercase: "La contrase√±a debe contener al menos una letra may√∫scula",
      lowercase: "La contrase√±a debe contener al menos una letra min√∫scula",
      number: "La contrase√±a debe contener al menos un n√∫mero",
      special:
        "La contrase√±a debe contener al menos un car√°cter especial @$!%*?&",
    },
    xRecaptchaToken: {
      required: "x-recaptcha-token es requerido",
      invalidFormat: "Formato de token inv√°lido",
    },
    name: {
      required: "Nombre es requerido",
      min: "Nombre debe tener al menos 3 caracteres",
      max: "Nombre debe tener como m√°ximo 32 caracteres",
    },
    error: {
      error: "error es requerido y debe ser un booleano",
      message: "message es requerido y debe ser una cadena",
      statusCode: "statusCode es requerido y debe ser un n√∫mero",
    },
    _id: "_id es requerido y debe ser un valido MongoDB ObjectId",
    createdAt: "createdAt es requerido y debe ser una fecha",
    updatedAt: "updatedAt es requerido y debe ser una fecha",
    rolesEnum: "roles solo debe contener valores del enum Roles",
    mongoDBStatusEnum:
      "mongoDBStatus solo debe contener valores del enum MongoDBStatus",
    redisStatusEnum:
      "redisStatus solo debe contener valores del enum RedisStatus",
    rabbitMQStatusEnum:
      "rabbitMQStatus solo debe contener valores del enum RabbitMQStatus",
    healthStatusEnum:
      "healthStatus solo debe contener valores del enum HealthStatus",
    isEmailVerified: "isEmailVerified debe ser un booleano",
    emailVerificationToken: "emailVerificationToken debe ser una cadena",
    forgotPasswordToken: "forgotPasswordToken debe ser una cadena",
    message: "message debe ser una cadena",
    tokenResetPassword: "token debe ser una cadena",
    tokenVerifyEmail: "token debe ser una cadena",
    latency: "latency debe ser un n√∫mero",
    errorHealth: "error debe ser una cadena",
    timestamp: "timestamp debe ser una cadena",
    version: "version debe ser una cadena",
    uptime: "uptime debe ser una cadena",
    uptimeSeconds: "uptimeSeconds debe ser un n√∫mero",
    userId: "userId debe ser una cadena",
    totalPages: "totalPages debe ser un n√∫mero",
    currentPage: "currentPage debe ser un n√∫mero",
    perPage: "perPage debe ser un n√∫mero",
    totalCount: "totalCount debe ser un n√∫mero",
    nonnegative: "debe ser un n√∫mero positivo",
  },
  schema: {
    summary: {
      registerUser: "Registrar usuario",
      login: "Iniciar sesi√≥n",
      logout: "Cerrar sesi√≥n",
      verifyEmail: "Verificar correo electr√≥nico",
      refreshToken: "Refresh token",
      resendLink: "Reenviar enlace",
      forgotPassword: "Olvid√© mi contrase√±a",
      getUserById: "Obtener usuario por ID",
      getUsers: "Obtener usuarios",
      resetPassword: "[REDACTED:password] contrase√±a",
      health: "Health check",
      downloadProto: "Descargar archivos proto",
    },
    tags: {
      authentication: "Autenticaci√≥n",
      users: "Usuarios",
      health: "Health",
      proto: "Proto",
    },
    info: {
      title: "gen-api",
      description: "Generar API",
    },
    security: {
      in: "cookie",
      name: "refreshToken",
      description: "Proporciona el refreshToken almacenado en un cookie",
    },
  },
  message: {
    index: {
      serverStarted: "Servidor iniciado en",
      healthEndpoint: "Health endpoint:",
      apiDocumentation: "Documentaci√≥n de la API:",
    },
    auth: {
      resendLinkSuccess:
        "Nuevo enlace de verificaci√≥n enviado a su correo electr√≥nico",
      linkResetPasswordSuccess:
        "Link para redefinir la contrase√±a enviado a su correo electr√≥nico",
      resetPasswordSuccess: "Contrase√±a redefinida con √©xito",
      logoutSuccessful: "Logout realizado con √©xito",
      tokensUpdatedSuccess: "Tokens actualizados con √©xito",
      userLogout: "Usuario %{userId} ha salido",
      newUserRegistered: "Nuevo usuario registrado: %{email}",
    },
    mongodb: {
      success: "MongoDB conectado correctamente",
      error: "Error al conectar a MongoDB",
      connectionNotReady: "La conexi√≥n con MongoDB no est√° lista",
      connectionFailed: "Fallo en la conexi√≥n con MongoDB",
    },
    redis: {
      notConfigured: "Redis no configurado",
      connectionStatus: "Estado de la conexi√≥n Redis: %{status}",
      pingFailed: "Ping de Redis fall√≥",
      healthCheckFailed: "Verificaci√≥n de salud de Redis fall√≥: %{error}",
    },
    time: {
      day: "dia",
      days: "dias",
    },
    email: {
      resetPassword: "Redefinir contrase√±a",
      clickLink:
        "Por favor, haga clic en el enlace a continuaci√≥n para redefinir su contrase√±a:",
      buttonMessage: "REDEFINIR CONTRASE√ëA",
      emailSent: "Correo electr√≥nico enviado:",
      errorEmailSent: "Error al enviar correo electr√≥nico:",
      confirmEmail: "Confirme su correo electr√≥nico",
      clickLinkVerify:
        "Por favor, haga clic en el enlace a continuaci√≥n para confirmar su correo electr√≥nico:",
      buttonVerify: "CONFIRMAR CORREO ELECTR√ìNICO",
    },
    prometheus: {
      httpInflightRequests: "N√∫mero de solicitudes simult√°neas",
      httpRequestsTotal: "N√∫mero total de solicitudes recibidas",
      httpRequestDurationSeconds:
        "Duraci√≥n de las solicitudes HTTP en segundos",
    },
    rabbitmq: {
      connectionSuccess: "‚úÖ RabbitMQ conectado y plugin registrado",
      connectionFailed: "Fallo en la conexi√≥n con RabbitMQ, reintentando...",
      connectionError: "Error en RabbitMQ:",
      connectionClosed: "Conexi√≥n con RabbitMQ cerrada",
      messagePublished: "üì© Mensaje publicado en [%{queue}]: %{message}",
      consumerStarted: "üéß Consumidor iniciado para la cola [%{queue}]",
      errorConnecting: "‚ùå Error al conectar a RabbitMQ:",
      connectionFailedDetailed:
        "No se pudo conectar a RabbitMQ despu√©s de m√∫ltiples intentos",
    },
    seeds: {
      adminCreated: "Usuario ADMIN creado con √©xito.",
      adminAlreadyExists: "Usuario ADMIN ya existe.",
    },
    logRotate: {
      subject: "%{appName} - Alerta de Rotaci√≥n de Registro",
      body: "Adjunto est√° el archivo de registro m√°s antiguo que se ha rotado.",
      successEmail: "Archivo de registro %{filePath} enviado a %{adminEmail}",
      errorEmail: "Error al enviar correo electr√≥nico de registro:",
      deleteLog: "Archivo de registro antiguo eliminado: %{filePath}",
      errorDeleteLog: "Error al eliminar archivo de registro: %{filePath}",
      errorRotate: "Error al rotar archivo de registro:",
      errorCheckLatest:
        "Error al verificar el archivo de registro m√°s reciente:",
    },
  },
};
