export default {
  error: {
    auth: {
      loginFailed: "Login failed",
      refreshTokenNotProvided: "Refresh token not provided",
      failedToRefreshTokens: "Failed to refresh tokens",
      failedToLogout: "Failed to logout",
      failedToVerifyEmail: "Failed to verify email",
      failedToResendLink: "Failed to resend verification link",
      failedToResetPassword: "Failed to reset password",
      emailAlreadyExists: "Email already exists",
      nameAlreadyExists: "Name already exists",
      emailNotVerified: "Email not verified",
      emailAlreadyVerified: "Email already verified",
      tokenNotProvided: "Token not provided",
      invalidAccessToken: "Invalid access token",
      invalidCredentials: "Invalid credentials",
      missingRequiredParameter: "Missing required parameter:",
      invalidTokenFormat: "Invalid token format",
      invalidToken: "Invalid token",
      cookieNotBeProcessed: "Authorization cookie could not be processed",
      authHeaderNotFound: "Authorization header not found",
      authCookieNotFound: "Authorization cookie not found",
      accessTokenExpired: "Access token expired",
      untrustedAccessToken: "Untrusted access token",
      accessTokenNotSigned: "Access token not signed",
      internalErrorAuthentication: "Internal error during authentication",
      userNotFound: "User not found",
      createUserError: "Error creating user",
      resendLinkError: "Error resending verification link",
      resetPasswordLinkError: "Error sending link to reset password",
      resetPasswordTokenNotFound: "Reset password token not found",
      resetPasswordTokenExpired: "Reset password token expired",
      resetPasswordError: "Error resetting password",
      notAuthorized: "Not authorized",
    },
    handler: {
      internalServerError: "Internal Server Error",
      recaptchaNotProvided: "reCAPTCHA not provided",
      recaptchaInvalid: "Invalid reCAPTCHA",
      unauthorized: "Unauthorized",
      tokenNotProvided: "Token not provided",
      tokenExpired: "Token expired",
      tokenInvalid: "Invalid token",
      responseSerializationError: "Response serialization error",
    },
    user: {
      notFound: "User not found",
      getUserById: "Error getting user by id",
      getUserByEmail: "Error getting user by email",
      getUserByName: "Error getting user by name",
      getUsers: "Error getting users",
    },
    invalidEnv: "Invalid environment variables:",
    ipBan: "IP temporarily banned due to multiple violations",
    rateLimitExceeded: "Too many requests, please try again later",
  },
  validation: {
    email: {
      invalid: "Invalid e-mail",
      max: "E-mail must be at most 254 characters long",
    },
    password: {
      required: "Password is required",
      min: "Password must be at least 8 characters",
      max: "Password must be at most 16 characters",
      uppercase: "Password must contain at least one uppercase letter",
      lowercase: "Password must contain at least one lowercase letter",
      number: "Password must contain at least one number",
      special: "Password must contain at least one special character @$!%*?&",
    },
    xRecaptchaToken: {
      required: "x-recaptcha-token is required",
      invalidFormat: "Invalid token format",
    },
    name: {
      required: "Name is required",
      min: "Name must be at least 3 characters long",
      max: "Name must be at most 32 characters long",
    },
    error: {
      error: "error is required and must be a boolean",
      message: "message is required and must be a string",
      statusCode: "statusCode is required and must be a number",
    },
    _id: "_id is required and must be a valid MongoDB ObjectId",
    createdAt: "createdAt is required and must be a date",
    updatedAt: "updatedAt is required and must be a date",
    rolesEnum: "roles should only contain values from the Roles enum",
    mongoDBStatusEnum:
      "mongoDBStatus should only contain values from the MongoDBStatus enum",
    redisStatusEnum:
      "redisStatus should only contain values from the RedisStatus enum",
    rabbitMQStatusEnum:
      "rabbitMQStatus should only contain values from the RabbitMQStatus enum",
    healthStatusEnum:
      "healthStatus should only contain values from the HealthStatus enum",
    isEmailVerified: "isEmailVerified must be a boolean",
    emailVerificationToken: "emailVerificationToken must be a string",
    forgotPasswordToken: "forgotPasswordToken must be a string",
    message: "message must be a string",
    tokenResetPassword: "token must be a string",
    tokenVerifyEmail: "token must be a string",
    latency: "latency must be a number",
    errorHealth: "error must be a string",
    timestamp: "timestamp must be a string",
    version: "version must be a string",
    uptime: "uptime must be a string",
    uptimeSeconds: "uptimeSeconds must be a number",
    userId: "userId must be a string",
    totalPages: "totalPages must be a number",
    currentPage: "currentPage must be a number",
    perPage: "perPage must be a number",
    totalCount: "totalCount must be a number",
    nonnegative: "must be a positive number",
  },
  schema: {
    summary: {
      registerUser: "Register user",
      login: "Login",
      logout: "Logout",
      verifyEmail: "Verify email",
      refreshToken: "Refresh token",
      resendLink: "Resend link",
      forgotPassword: "Forgot password",
      getUserById: "Get user by ID",
      getUsers: "Get users",
      resetPassword: "Reset password",
      health: "Health check",
      downloadProto: "Download proto files",
    },
    tags: {
      authentication: "Authentication",
      users: "Users",
      health: "Health",
      proto: "Proto",
    },
    info: {
      title: "gen-api",
      description: "Generate API",
    },
    security: {
      in: "cookie",
      name: "refreshToken",
      description: "Provide the refreshToken stored in a cookie",
    },
  },
  message: {
    index: {
      serverStarted: "Server started in",
      healthEndpoint: "Health endpoint:",
      apiDocumentation: "API documentation:",
    },
    auth: {
      resendLinkSuccess: "New verification link sent to email",
      linkResetPasswordSuccess: "Link to reset password sent to email",
      resetPasswordSuccess: "Password reset successfully",
      logoutSuccessful: "Logout successful",
      tokensUpdatedSuccess: "Tokens updated successfully",
      userLogout: "User %{userId} logged out",
      newUserRegistered: "New user registered: %{email}",
    },
    mongodb: {
      success: "MongoDB connected successfully",
      error: "MongoDB connection error",
      connectionNotReady: "MongoDB connection not ready",
      connectionFailed: "MongoDB connection failed",
    },
    redis: {
      notConfigured: "Redis not configured",
      connectionStatus: "Redis connection status: %{status}",
      pingFailed: "Redis ping failed",
      healthCheckFailed: "Redis health check failed: %{error}",
    },
    time: {
      day: "day",
      days: "days",
    },
    email: {
      resetPassword: "Reset password",
      clickLink: "Please click the link below to reset your password:",
      buttonMessage: "RESET PASSWORD",
      emailSent: "Email sent: ",
      errorEmailSent: "Error sending email:",
      confirmEmail: "Confirm your email",
      clickLinkVerify: "Please click the link below to confirm your email:",
      buttonVerify: "CONFIRM EMAIL",
    },
    prometheus: {
      httpInflightRequests: "Number of concurrent requests",
      httpRequestsTotal: "Total number of requests received",
      httpRequestDurationSeconds: "Duration of HTTP requests in seconds",
    },
    rabbitmq: {
      connectionSuccess: "‚úÖ RabbitMQ connected and plugin registered",
      connectionFailed: "RabbitMQ connection failed, retrying...",
      connectionError: "RabbitMQ error:",
      connectionClosed: "RabbitMQ connection closed",
      messagePublished: "üì© Message published in [%{queue}]: %{message}",
      consumerStarted: "üéß Consumer started for queue [%{queue}]",
      errorConnecting: "‚ùå Error connecting to RabbitMQ:",
      connectionFailedDetailed:
        "Could not connect to RabbitMQ after multiple attempts",
    },
    seeds: {
      adminCreated: "User ADMIN created successfully.",
      adminAlreadyExists: "User ADMIN already exists.",
    },
    logRotate: {
      subject: "%{appName} - Log Rotation Alert",
      body: "Attached is the oldest log file which has been rotated out.",
      successEmail: "Log file %{filePath} sent to %{adminEmail}",
      errorEmail: "Failed to send log email:",
      deleteLog: "Deleted old log file: %{filePath}",
      errorDeleteLog: "Failed to delete log file: %{filePath}",
      errorRotate: "Failed to rotate log file:",
      errorCheckLatest: "Failed to check latest log file:",
    },
  },
};
