export default {
  error: {
    auth: {
      loginFailed: "Erro ao fazer login",
      refreshTokenNotProvided: "Token de atualiza√ß√£o n√£o fornecido",
      failedToRefreshTokens: "Falha ao atualizar tokens",
      failedToLogout: "Erro ao fazer logout",
      failedToVerifyEmail: "Erro ao verificar e-mail",
      failedToResendLink: "Erro ao reenviar link de verifica√ß√£o",
      failedToResetPassword: "Erro ao resetar senha",
      emailAlreadyExists: "E-mail j√° existe",
      nameAlreadyExists: "Nome j√° existe",
      emailNotVerified: "E-mail n√£o verificado",
      emailAlreadyVerified: "E-mail j√° verificado",
      tokenNotProvided: "Token n√£o fornecido",
      invalidCredentials: "Credenciais inv√°lidas",
      missingRequiredParameter: "Par√¢metro obrigat√≥rio:",
      invalidTokenFormat: "Formato de token inv√°lido",
      invalidToken: "Token inv√°lido",
      cookieNotBeProcessed: "Cookie de autoriza√ß√£o n√£o pode ser processado",
      authHeaderNotFound: "Header de autoriza√ß√£o n√£o encontrado",
      authCookieNotFound: "Cookie de autoriza√ß√£o n√£o encontrado",
      accessTokenExpired: "Access token expirado",
      untrustedAccessToken: "Access token n√£o confi√°vel",
      accessTokenNotSigned: "Access token n√£o assinado",
      invalidAccessToken: "Token de acesso inv√°lido",
      internalErrorAuthentication: "Erro interno durante a autentica√ß√£o",
      userNotFound: "Usu√°rio n√£o encontrado",
      createUserError: "Erro ao criar usu√°rio",
      resendLinkError: "Erro ao reenviar link de verifica√ß√£o",
      resetPasswordLinkError: "Erro ao enviar link para redefinir senha",
      resetPasswordTokenNotFound:
        "Token de redefini√ß√£o de senha n√£o encontrado",
      resetPasswordTokenExpired: "Token de redefini√ß√£o de senha expirado",
      resetPasswordError: "Erro ao redefinir senha",
      notAuthorized: "N√£o autorizado",
    },
    handler: {
      internalServerError: "Erro interno do servidor",
      recaptchaNotProvided: "reCAPTCHA n√£o fornecido",
      recaptchaInvalid: "reCAPTCHA inv√°lido",
      unauthorized: "N√£o autorizado",
      tokenNotProvided: "Token n√£o fornecido",
      tokenExpired: "Token expirado",
      tokenInvalid: "Token inv√°lido",
      responseSerializationError: "Erro de serializa√ß√£o da resposta",
    },
    user: {
      notFound: "Usu√°rio n√£o encontrado",
      getUserById: "Erro ao buscar usu√°rio por id",
      getUserByEmail: "Erro ao buscar usu√°rio por e-mail",
      getUserByName: "Erro ao buscar usu√°rio por nome",
      getUsers: "Erro ao buscar usu√°rios",
    },
    invalidEnv: "Vari√°veis de ambiente inv√°lidas:",
    ipBan: "IP temporariamente banido devido a m√∫ltiplas viola√ß√µes",
    rateLimitExceeded: "Muitas requisi√ß√µes, tente novamente mais tarde",
  },
  validation: {
    email: {
      invalid: "E-mail inv√°lido",
      max: "E-mail deve ter no m√°ximo 254 caracteres",
    },
    password: {
      required: "A senha √© obrigat√≥ria",
      min: "A senha deve ter pelo menos 8 caracteres",
      max: "A senha deve ter no m√°ximo 16 caracteres",
      uppercase: "A senha deve ter pelo menos uma letra mai√∫scula",
      lowercase: "A senha deve ter pelo menos uma letra min√∫scula",
      number: "A senha deve ter pelo menos um n√∫mero",
      special: "A senha deve ter pelo menos um caractere especial @$!%*?&",
    },
    xRecaptchaToken: {
      required: "x-recaptcha-token √© obrigat√≥rio",
      invalidFormat: "Formato de token inv√°lido",
    },
    name: {
      required: "Nome √© obrigat√≥rio",
      min: "Nome deve ter pelo menos 3 caracteres",
      max: "Nome deve ter no m√°ximo 32 caracteres",
    },
    error: {
      error: "error √© obrigat√≥rio e deve ser um booleano",
      message: "message √© obrigat√≥rio e deve ser uma string",
      statusCode: "statusCode √© obrigat√≥rio e deve ser um n√∫mero",
    },
    _id: "_id √© obrigat√≥rio e deve ser um MongoDB ObjectId v√°lido",
    createdAt: "createdAt √© obrigat√≥rio e deve ser uma data",
    updatedAt: "updatedAt √© obrigat√≥rio e deve ser uma data",
    rolesEnum: "roles s√≥ deve conter valores do enum Roles",
    mongoDBStatusEnum:
      "mongoDBStatus s√≥ deve conter valores do enum MongoDBStatus",
    redisStatusEnum: "redisStatus s√≥ deve conter valores do enum RedisStatus",
    rabbitMQStatusEnum:
      "rabbitMQStatus s√≥ deve conter valores do enum RabbitMQStatus",
    healthStatusEnum:
      "healthStatus s√≥ deve conter valores do enum HealthStatus",
    isEmailVerified: "isEmailVerified deve ser um booleano",
    emailVerificationToken: "emailVerificationToken deve ser uma string",
    forgotPasswordToken: "forgotPasswordToken deve ser uma string",
    message: "message deve ser uma string",
    tokenResetPassword: "token deve ser uma string",
    tokenVerifyEmail: "token deve ser uma string",
    latency: "latency deve ser um n√∫mero",
    errorHealth: "error deve ser uma string",
    timestamp: "timestamp deve ser uma string",
    version: "version deve ser uma string",
    uptime: "uptime deve ser uma string",
    uptimeSeconds: "uptimeSeconds deve ser um n√∫mero",
    userId: "userId deve ser uma string",
    totalPages: "totalPages deve ser um n√∫mero",
    currentPage: "currentPage deve ser um n√∫mero",
    perPage: "perPage deve ser um n√∫mero",
    totalCount: "totalCount deve ser um n√∫mero",
    nonnegative: "deve ser um n√∫mero positivo",
  },
  schema: {
    summary: {
      registerUser: "Registrar usu√°rio",
      login: "Login",
      logout: "Logout",
      verifyEmail: "Verificar e-mail",
      refreshToken: "Refresh token",
      resendLink: "Reenviar link",
      forgotPassword: "Esqueceu sua senha",
      getUserById: "Obter usu√°rio por ID",
      getUsers: "Obter usu√°rios",
      resetPassword: "Redefinir senha",
      health: "Health check",
      downloadProto: "Baixar arquivos proto",
    },
    tags: {
      authentication: "Autentica√ß√£o",
      users: "Usu√°rios",
      health: "Health",
      proto: "Proto",
    },
    info: {
      title: "gen-api",
      description: "Gerar API",
    },
    security: {
      in: "cookie",
      name: "refreshToken",
      description: "Informe o refreshToken armazenado em cookie",
    },
  },
  message: {
    index: {
      serverStarted: "Servidor iniciado em",
      healthEndpoint: "Health endpoint:",
      apiDocumentation: "Documenta√ß√£o da API:",
    },
    auth: {
      resendLinkSuccess: "Novo link de verifica√ß√£o enviado para o e-mail",
      linkResetPasswordSuccess:
        "Link para redefinir a senha enviado para o e-mail",
      resetPasswordSuccess: "Contrase√±a redefinida com sucesso",
      logoutSuccessful: "Logout realizado com sucesso",
      tokensUpdatedSuccess: "Tokens atualizados com sucesso",
      userLogout: "Usu√°rio %{userId} deslogado",
      newUserRegistered: "Novo usu√°rio registrado: %{email}",
    },
    mongodb: {
      success: "MongoDB conectado com sucesso",
      error: "Erro ao conectar a MongoDB",
      connectionNotReady: "Conex√£o com MongoDB n√£o est√° pronta",
      connectionFailed: "Falha na conex√£o com MongoDB",
    },
    redis: {
      notConfigured: "Redis n√£o configurado",
      connectionStatus: "Status da conex√£o Redis: %{status}",
      pingFailed: "Ping do Redis falhou",
      healthCheckFailed: "Verifica√ß√£o de sa√∫de do Redis falhou: %{error}",
    },
    time: {
      day: "dia",
      days: "dias",
    },
    email: {
      resetPassword: "Recadastrar senha",
      clickLink:
        "Por favor, clique no link abaixo para recadastrar a sua senha:",
      buttonMessage: "RECADASTRAR SENHA",
      emailSent: "E-mail enviado:",
      errorEmailSent: "Erro ao enviar e-mail:",
      confirmEmail: "Confirme seu e-mail",
      clickLinkVerify:
        "Por favor, clique no link abaixo para confirmar seu e-mail:",
      buttonVerify: "CONFIRMAR E-MAIL",
    },
    prometheus: {
      httpInflightRequests: "N√∫mero de requisi√ß√µes simult√¢neas",
      httpRequestsTotal: "N√∫mero total de requisi√ß√µes recebidas",
      httpRequestDurationSeconds: "Dura√ß√£o das requisi√ß√µes HTTP em segundos",
    },
    rabbitmq: {
      connectionSuccess: "‚úÖ RabbitMQ conectado e plugin registrado",
      connectionFailed: "Falha na conex√£o com RabbitMQ, tentando novamente...",
      connectionError: "Erro no RabbitMQ:",
      connectionClosed: "Conex√£o com RabbitMQ fechada",
      messagePublished: "üì© Mensagem publicada em [%{queue}]: %{message}",
      consumerStarted: "üéß Consumidor iniciado para a fila [%{queue}]",
      errorConnecting: "‚ùå Erro ao conectar RabbitMQ:",
      connectionFailedDetailed:
        "N√£o foi poss√≠vel conectar ao RabbitMQ ap√≥s m√∫ltiplas tentativas",
    },
    seeds: {
      adminCreated: "Usu√°rio ADMIN criado com sucesso.",
      adminAlreadyExists: "Usu√°rio ADMIN j√° existe.",
    },
    logRotate: {
      subject: "%{appName} - Alerta de Rota√ß√£o de Log",
      body: "Em anexo est√° o arquivo de log mais antigo que foi rotacionado.",
      successEmail: "Arquivo de log %{filePath} enviado para %{adminEmail}",
      errorEmail: "Falha ao enviar e-mail de log:",
      deleteLog: "Arquivo de log antigo exclu√≠do: %{filePath}",
      errorDeleteLog: "Falha ao excluir arquivo de log: %{filePath}",
      errorRotate: "Falha ao rotacionar arquivo de log:",
      errorCheckLatest: "Falha ao verificar o arquivo de log mais recente:",
    },
  },
};
